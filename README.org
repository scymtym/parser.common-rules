#+TITLE:       parser.common-rules README
#+AUTHOR:      Jan Moringen
#+EMAIL:       jmoringe@techfak.uni-bielefeld.de
#+DESCRIPTION:
#+KEYWORDS:    parser, expression, infix, common rules, esrap
#+LANGUAGE:    en

* Introduction
  This system provides rules and rule-constructing macros for the
  [[https://github.com/scymtym/esrap][esrap parser library]] for common cases in the following categories:

  + Anchors :: Rules that match if the input around the position in
       question has certain properties.

  + Whitespace :: Rules related to whitespace.

  + Comments :: Rules for parsing different kinds of comments commonly
       used in programming languages.

  + Literals :: Rules for parsing commonly used literals such as
       booleans, numbers and strings.

  + Tokenization :: Macros for handling tokenization (which is usually
       not done in a separate lexing step in esrap-based parsers).

  + Infix Operators :: Macros for defining families of unary and
       binary operators with given precedence relations and
       associativity.

* TODO Tutorial
  #+BEGIN_SRC lisp :results silent :exports results :session "tutorial"
    (ql:quickload :parser.common-rules)
  #+END_SRC
** Anchors
   "Anchor" rules match when the input around the current position has
   certain properties and do not consume any input. For example:
   #+BEGIN_SRC lisp :results value scalar :exports both :session "tutorial"
     (esrap:parse 'parser.common-rules:<beginning-of-line> (format nil "foo~%bar")
                  :start 4 :junk-allowed t)
   #+END_SRC

   #+RESULTS:
   : :BEGINNING-OF-LINE
   : 4
   : T

   The rules src_lisp[:exports code]{<end-of-line>},
   src_lisp[:exports code]{<beginning-of-input>} and
   src_lisp[:exports code]{<end-of-input>} work similarly.

   The final rule, src_lisp[:exports code]{<same-line>} is different
   in that it does consume input:

   #+BEGIN_SRC lisp :results value scalar :exports both :session "tutorial"
     (esrap:parse 'parser.common-rules:<same-line> (format nil "foo bar~%baz")
                  :start 4 :junk-allowed t)
   #+END_SRC

   #+RESULTS:
   : "bar"
   : 7
   : T

** Whitespace
   The whitespace-related rules should be pretty self-explanatory:

   #+BEGIN_SRC lisp :results value scalar :exports both :session "tutorial"
     (esrap:parse 'parser.common-rules:whitespace+ "  ")
   #+END_SRC

   #+RESULTS:
   : NIL
   : NIL
   : T

** Comments
   There are several rules for parsing different styles of comments
   commonly used in programming languages. For example, the following
   rule parses src_c[:exports code]{/* … */} comments:

   #+BEGIN_SRC lisp :results value scalar :exports both :session "tutorial"
     (esrap:parse
      'parser.common-rules:c-style-comment/delimited
      "/*
        * Foo bar
        */")
   #+END_SRC

   #+RESULTS:
   : "
   :    * Foo bar
   :    "
   : NIL
   : T

   The above production is faithful to the input text with respect to
   whitespace, but that is not always desired. In such cases, the
   following comes in handy:

   #+BEGIN_SRC lisp :results value scalar :exports both :session "tutorial"
     (esrap:parse
      'parser.common-rules:c-style-comment/delimited/trimmed
      "/*
        * Foo bar
        ** fez baz
        * * whoop
        */")
   #+END_SRC

   #+RESULTS:
   : "Foo bar
   :  fez baz
   : * whoop"
   : NIL
   : T

   Note how prefixes of the same length are trimmed from all lines and
   the =* whoop= in the third comment line remains intact.

* TODO Dictionary
  #+BEGIN_SRC lisp :results silent :exports results :session "doc"
    (ql:quickload '(:alexandria :split-sequence :parser.common-rules))
    (defun doc (symbol kind)
      (let* ((lambda-list (sb-introspect:function-lambda-list symbol))
             (string      (or (documentation symbol kind)
                              (error "~@<~A ~S is not documented.~@:>"
                                     kind symbol)))
             (lines       (split-sequence:split-sequence #\Newline string))
             (strip       (reduce
                           #'min (rest lines)
                           :key (lambda (line)
                                  (or (position #\Space line :test-not #'char=)
                                      most-positive-fixnum))))
             (trimmed     (mapcar (lambda (line)
                                    (subseq line (min strip (length line))))
                                  (rest lines))))
        (format nil "~(~A~) ~<~{~A~^ ~}~:@>~2%~{~A~^~%~}"
                symbol (list lambda-list) (list* (first lines) trimmed))))
  #+END_SRC
** Anchors
   #+BEGIN_EXAMPLE
     <beginning-of-input>

     Matches at the beginning of the input (i.e. there is no preceding
     character). Produces :beginning-of-input and does not consume input.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     <end-of-input>

     Matches at the end of the input line (i.e. there is no following
     character). Produces :end-of-input and does not consume input.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     <beginning-of-line>

     Matches at the beginning of a line (i.e. the preceding character is
     #\Newline or there is no preceding character). Produces
     :beginning-of-line and does not consume input.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     <end-of-line>

     Matches at the end of a line (i.e. the following character is
     #\Newline or there is no following character). Produces :end-of-line
     and does not consume input.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     <same-line>

     Consumes all characters until <end-of-line> and produces the resulting
     string.
   #+END_EXAMPLE

** Whitespace
   #+BEGIN_EXAMPLE
     whitespace/not-newline

     Consumes a single #\Space or #\Tab, produces nil.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     whitespace/not-newline?

     Consumes nothing or a single #\Space or #\Tab, produces nil.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     whitespace

     Consumes a single #\Tab, #\Space, #\Newline or #\Page, produces nil.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     whitespace?

     Consumes nothing or a single #\Tab, #\Space, #\Newline or #\Page,
     produces nil.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     whitespace+

     Consumes one or more #\Tab, #\Space, #\Newline or #\Page characters,
     produces nil.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     whitespace*

     Consumes zero or more #\Tab, #\Space, #\Newline or #\Page characters,
     produces nil.
   #+END_EXAMPLE

** Comments
   #+BEGIN_EXAMPLE
     c-style-comment/rest-of-line[/trimmed]

     Consumes a comment of the form // … <end-of-line>, produces a string
     from the enclosed characters. The /trimmed variant removes leading
     #\/ characters. The plain variant uses the character unmodified.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     c-style-comment/delimited[/trimmed]

     Consumes a comment of the form /* … */, produces a string from the
     enclosed characters. The /trimmed variant removes a common prefix
     consisting of #\Space and #\* characters. The plain variant uses the
     enclosed characters unmodified.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     shell-style-comment[/trimmed]

     Consumes a comment of the form # … <end-of-line>, produces a string
     from the enclosed characters. The /trimmed variant removes leading
     #\# characters. The plain variant uses the character unmodified.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     lisp-style-comment[/trimmed]

     Consumes a comment of the form ; … <end-of-line>, produces a string
     from the enclosed characters. The /trimmed variant removes leading
     #\; characters. The plain variant uses the character unmodified.
   #+END_EXAMPLE

* Settings                                                         :noexport:

#+OPTIONS: H:2 num:nil toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS: TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
