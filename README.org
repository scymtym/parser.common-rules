#+TITLE:       parser.common-rules README
#+AUTHOR:      Jan Moringen
#+EMAIL:       jmoringe@techfak.uni-bielefeld.de
#+DESCRIPTION:
#+KEYWORDS:    parser, expression, infix, common rules, esrap
#+LANGUAGE:    en

* Introduction
  This system provides rules and rule-constructing macros for the
  [[https://github.com/scymtym/esrap][esrap parser library]] for common cases in the following categories:

  + Anchors :: Rules that match if the input around the position in
       question has certain properties.

  + Whitespace :: Rules related to whitespace.

  + Comments :: Rules for parsing different kinds of comments commonly
       used in programming languages.

  + Literals :: Rules for parsing commonly used literals such as
       booleans, numbers and strings.

  + Tokenization :: Macros for handling tokenization (which is usually
       not done in a separate lexing step in esrap-based parsers).

  + Infix Operators :: Macros for defining families of unary and
       binary operators with given precedence relations and
       associativity.

* TODO Tutorial
  #+BEGIN_SRC lisp :results silent :exports results :session "tutorial"
    (ql:quickload :parser.common-rules)
  #+END_SRC
** Anchors
   "Anchor" rules match when the input around the current position has
   certain properties and do not consume any input. For example:
   #+BEGIN_SRC lisp :results value scalar :exports both :session "tutorial"
     (esrap:parse 'parser.common-rules:<beginning-of-line> (format nil "foo~%bar")
                  :start 4 :junk-allowed t)
   #+END_SRC

   #+RESULTS:
   : :BEGINNING-OF-LINE
   : 4
   : T

   The rules src_lisp[:exports code]{<end-of-line>},
   src_lisp[:exports code]{<beginning-of-input>} and
   src_lisp[:exports code]{<end-of-input>} work similarly.

   The final rule, src_lisp[:exports code]{<same-line>} is different
   in that it does consume input:

   #+BEGIN_SRC lisp :results value scalar :exports both :session "tutorial"
     (esrap:parse 'parser.common-rules:<same-line> (format nil "foo bar~%baz")
                  :start 4 :junk-allowed t)
   #+END_SRC

   #+RESULTS:
   : "bar"
   : 7
   : T

** Whitespace
   The whitespace-related rules should be pretty self-explanatory:

   #+BEGIN_SRC lisp :results value scalar :exports both :session "tutorial"
     (esrap:parse 'parser.common-rules:whitespace+ "  ")
   #+END_SRC

   #+RESULTS:
   : NIL
   : NIL
   : T

** Comments
   There are several rules for parsing different styles of comments
   commonly used in programming languages. For example, the following
   rule parses src_c[:exports code]{/* … */} comments:

   #+BEGIN_SRC lisp :results value scalar :exports both :session "tutorial"
     (esrap:parse
      'parser.common-rules:c-style-comment/delimited
      "/*
        * Foo bar
        */")
   #+END_SRC

   #+RESULTS:
   : "
   :    * Foo bar
   :    "
   : NIL
   : T

   The above production is faithful to the input text with respect to
   whitespace, but that is not always desired. In such cases, the
   following comes in handy:

   #+BEGIN_SRC lisp :results value scalar :exports both :session "tutorial"
     (esrap:parse
      'parser.common-rules:c-style-comment/delimited/trimmed
      "/*
        * Foo bar
        ** fez baz
        * * whoop
        */")
   #+END_SRC

   #+RESULTS:
   : "Foo bar
   :  fez baz
   : * whoop"
   : NIL
   : T

   Note how prefixes of the same length are trimmed from all lines and
   the =* whoop= in the third comment line remains intact.

** Literals
   The system provides rules for parsing Boolean, integer, floating
   point and string literals. The two most interesting are probably

   1. floating point literals

      #+BEGIN_SRC lisp :results value scalar :exports both :session "tutorial"
        (esrap:parse 'parser.common-rules:float-literal "0.12e-10")
      #+END_SRC

      #+RESULTS:
      : 1.2f-11
      : NIL
      : T

   2. string literals

      #+BEGIN_SRC lisp :results value scalar :exports both :session "tutorial"
        (esrap:parse 'parser.common-rules:string-literal/double-quotes
                     "\" foo \\\" bar \\x041 \\\\ baz \"")
      #+END_SRC

      #+RESULTS:
      : " foo \" bar A \\ baz "
      : NIL
      : T

      #+BEGIN_SRC lisp :results value scalar :exports both :session "tutorial"
        (esrap:parse 'parser.common-rules:string-literal/sextuple-quotes
                     "\"\"\" foo \\\" bar \\x041 \\\\ baz \"\"\"")
      #+END_SRC

      #+RESULTS:
      : " foo \\\" bar \\x041 \\\\ baz "
      : NIL
      : T

** Tokenization
   Esrap-based grammars in most cases work without a separate lexical
   analysis phase. Among other things, this implies that the grammar
   rules have to handle tokenization. This system provides the
   src_lisp[:exports code]{defrule/s} macro to automate some of this
   effort.

   The macro is used in place of
   src_lisp[:exports code]{esrap:defrule} to define rules which parse
   token-like things. For example

   #+BEGIN_SRC lisp :results silent :exports both :session "tutorial"
     (parser.common-rules:defrule/s (identifier
                                     :skippable-expression  parser.common-rules:whitespace+
                                     :skippable?-expression parser.common-rules:whitespace*)
         (and (esrap:character-ranges (#\a #\z) (#\A #\Z))
              (* (esrap:character-ranges (#\a #\z) (#\A #\Z) (#\0 #\9))))
       (:text t))
   #+END_SRC

   Instead of one rule src_lisp[:exports code]{identifier}, this form
   defines up to three rules
   + src_lisp[:exports code]{identifier}
   + src_lisp[:exports code]{identifier/s}
   + src_lisp[:exports code]{identifier/?s}
   The second and third rule parse an identifier followed by mandatory
   and optional "skippable" text (i.e. some form of whitespace in most
   cases) respectively. These rules can be used in places that require
   or allow an identifier to be separated by whitespace from the next
   token. For example:

   #+BEGIN_SRC lisp :results silent :exports both :session "tutorial"
     (parser.common-rules:defrule/s (equals
                                     :skippable-expression  parser.common-rules:whitespace+
                                     :skippable?-expression parser.common-rules:whitespace*)
         #\=)

     (esrap:defrule declaration
         (and identifier/?s equals/?s (* (digit-char-p character))))
   #+END_SRC

   This rules behaves like a parser with lexical analysis phase would:

   #+BEGIN_SRC lisp :results value table:exports both :session "tutorial" :colnames '("input" "production")
     (mapcar (lambda (input)
               (list (prin1-to-string input)
                     (princ-to-string (esrap:parse 'declaration input))))
             '("a=1" "a =1" "a= 1" "a = 1"))
   #+END_SRC

   #+RESULTS:
   | input   | production |
   |---------+------------|
   | "a=1"   | (a = (1))  |
   | "a =1"  | (a = (1))  |
   | "a= 1"  | (a = (1))  |
   | "a = 1" | (a = (1))  |

   Note that skippable text before and after the declaration is not
   handled by this rule but in the respective context in which the
   src_lisp[:exports code]{declaration} rule is used (This could
   require defining the src_lisp[:exports code]{declaration} rule
   using src_lisp[:exports code]{defrule/s} as well).

   The unwieldy specification of skippable expressions

   #+BEGIN_SRC lisp :exports code
     (parser.common-rules:defrule/s (identifier
                                     :skippable-expression  parser.common-rules:whitespace+
                                     :skippable?-expression parser.common-rules:whitespace*)
         …)
   #+END_SRC

   can be avoided by defining rules for skippable text in the package
   of the symbol naming the rule:

   #+BEGIN_SRC lisp :results silent :exports both :session "tutorial"
     (esrap:defrule skippable
         parser.common-rules:whitespace+)

     (esrap:defrule skippable?
         parser.common-rules:whitespace*)

     (parser.common-rules:defrule/s (identifier)
         (and (esrap:character-ranges (#\a #\z) (#\A #\Z))
              (* (esrap:character-ranges (#\a #\z) (#\A #\Z) (#\0 #\9))))
       (:text t))
   #+END_SRC

   These rules can then be shared by all rules defined with
   src_lisp[:exports code]{defrule/s}.

* TODO Dictionary
  #+BEGIN_SRC lisp :results silent :exports results :session "doc"
    (ql:quickload '(:alexandria :split-sequence :parser.common-rules))
    (defun doc (symbol kind)
      (let* ((lambda-list (sb-introspect:function-lambda-list symbol))
             (string      (or (documentation symbol kind)
                              (error "~@<~A ~S is not documented.~@:>"
                                     kind symbol)))
             (lines       (split-sequence:split-sequence #\Newline string))
             (strip       (reduce
                           #'min (rest lines)
                           :key (lambda (line)
                                  (or (position #\Space line :test-not #'char=)
                                      most-positive-fixnum))))
             (trimmed     (mapcar (lambda (line)
                                    (subseq line (min strip (length line))))
                                  (rest lines))))
        (format nil "~(~A~) ~<~{~A~^ ~}~:@>~2%~{~A~^~%~}"
                symbol (list lambda-list) (list* (first lines) trimmed))))
  #+END_SRC
** Anchors
   #+BEGIN_EXAMPLE
     <beginning-of-input>

     Matches at the beginning of the input (i.e. there is no preceding
     character). Produces :beginning-of-input and does not consume input.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     <end-of-input>

     Matches at the end of the input line (i.e. there is no following
     character). Produces :end-of-input and does not consume input.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     <beginning-of-line>

     Matches at the beginning of a line (i.e. the preceding character is
     #\Newline or there is no preceding character). Produces
     :beginning-of-line and does not consume input.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     <end-of-line>

     Matches at the end of a line (i.e. the following character is
     #\Newline or there is no following character). Produces :end-of-line
     and does not consume input.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     <same-line>

     Consumes all characters until <end-of-line> and produces the resulting
     string.
   #+END_EXAMPLE

** Whitespace
   #+BEGIN_EXAMPLE
     whitespace/not-newline

     Consumes a single #\Space or #\Tab, produces nil.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     whitespace/not-newline?

     Consumes nothing or a single #\Space or #\Tab, produces nil.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     whitespace

     Consumes a single #\Tab, #\Space, #\Newline or #\Page, produces nil.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     whitespace?

     Consumes nothing or a single #\Tab, #\Space, #\Newline or #\Page,
     produces nil.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     whitespace+

     Consumes one or more #\Tab, #\Space, #\Newline or #\Page characters,
     produces nil.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     whitespace*

     Consumes zero or more #\Tab, #\Space, #\Newline or #\Page characters,
     produces nil.
   #+END_EXAMPLE

** Comments
   #+BEGIN_EXAMPLE
     c-style-comment/rest-of-line[/trimmed]

     Consumes a comment of the form // … <end-of-line>, produces a string
     from the enclosed characters. The /trimmed variant removes leading
     #\/ characters. The plain variant uses the character unmodified.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     c-style-comment/delimited[/trimmed]

     Consumes a comment of the form /* … */, produces a string from the
     enclosed characters. The /trimmed variant removes a common prefix
     consisting of #\Space and #\* characters. The plain variant uses the
     enclosed characters unmodified.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     shell-style-comment[/trimmed]

     Consumes a comment of the form # … <end-of-line>, produces a string
     from the enclosed characters. The /trimmed variant removes leading
     #\# characters. The plain variant uses the character unmodified.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     lisp-style-comment[/trimmed]

     Consumes a comment of the form ; … <end-of-line>, produces a string
     from the enclosed characters. The /trimmed variant removes leading
     #\; characters. The plain variant uses the character unmodified.
   #+END_EXAMPLE

** Literals
   #+BEGIN_EXAMPLE
     boolean-literal/{lower-case,capital-case,extended}

     Consumes a Boolean value of the form

          true | false
       or True | False
       or true | false | t | f | 1 | 0

     respectively and produces t or nil.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     integer-literal/{octal[/prefix],decimal,hexdecimal[/prefix]}

     Consumes an integer literal and produces its value.

     Variants:

                    /prefix         plain
       octal        {+,-,}0o[0-7]+  {+,-,}[0-7]+
       decimal                      {+,-,}[0-9]+
       hexadecimal  {+,-,}0x[0-f]+  {+,-,}[0-f]+
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     float-literal[/rational]

     Consumes a floating point literal in fixed or scientific notation and
     produces its value.

     The /rational variant returns the parsed number as a rational value
     while the plain variant coerces the parsed number into a single-float.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     number-literal

     Consumes an integer or float literal and produces its value. In case
     of a float literal, a single-float value is returned.
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
     string-literal-{single,double,triple,sextuple}-quotes

     Consumes a string literal delimited by ', ", ''' or """ respectively.
     Produces the content of the literal (i.e. excluding the delimiters) as
     a string.

     For the single-quote and double-quote rules, the #\\ character
     initiates escape sequences. The following escape sequences are
     recognized:

       \\                                       -> #\Backslash

       \a                                       -> #\Bel
       \b                                       -> #\Backspace
       \f                                       -> #\Page
       \n                                       -> #\Newline
       \r                                       -> #\Return
       \t                                       -> #\Tab
       \v                                       -> #\Line_Tabulation

       \<octal number below decimal 256>        -> the character with that code
       \x<hexadecimal number below decimal 256> -> the character with that code
   #+END_EXAMPLE

** Tokenization
   #+BEGIN_SRC lisp :exports results :session "doc"
     (doc 'parser.common-rules:defrule/s 'function)
   #+END_SRC

   #+RESULTS:
   #+begin_example
   defrule/s NAME-AND-OPTIONS EXPRESSION &BODY OPTIONS

   Like `esrap:defule' but define additional rules named NAME/s and
   NAME/?s which respectively require/allow EXPRESSION to be followed
   by skippable input (e.g. whitespace).

   NAME-AND-OPTIONS can be either just a rule name or a list of the
   form

     (NAME &key
           SKIPPABLE-EXPRESSION  S?
           SKIPPABLE?-EXPRESSION ?S?
           DEFINER)

   where SKIPPABLE-EXPRESSION and SKIPPABLE?-EXPRESSION name the rules
   used to parse skippable input in the NAME/s and NAME/?s
   variants. Default to `skippable' and `skippable?' respectively.

   S? and ?S? control which of the NAME/S and NAME/?S rules should be
   generated. Default is generating both.

   DEFINER is the name of the macro used to define the "main"
   rule. Defaults to `esrap:defrule'.
   #+end_example

* Settings                                                         :noexport:

#+OPTIONS: H:2 num:nil toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS: TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
